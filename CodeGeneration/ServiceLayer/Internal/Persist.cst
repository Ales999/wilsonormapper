<%-- 
Written by Brian DeMarzo (http://www.demarzo.net)
Derived from CodeSmith templates by Paul Weiter
--%>
<%@ CodeTemplate 
	Language="C#" 
	TargetLanguage="C#" 
	Description="Generate a static Persist<T> class for Wilson O/R Mapper. Requires .Net 2.0." 
	Debug="true" %>
	
<%@ Register Name="CommonProperties" Template="CommonProperties.cst" MergeProperties="True" ExcludeProperties="" %>
//------------------------------------------------------------------------------
// <autogenerated>
//		This code was generated by a CodeSmith Template.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Text;
using Wilson.ORMapper;
using <%= EntityNamespace %>;

namespace <%= DataAccessNamespace %>
{
	public class Persist<T> : Retrieve<T> where T : IPersistable, new()
	{
		#region Constructors
		protected Persist()
			: base()
        {
        }
        #endregion
        
        #region Save
        ///<summary>Save an instance to the persistence store</summary>
        ///<exception cref="ValidationException">Throws VaidationException when not <see cref="IsValid"/>.</exception>
		public static void Save(T instance)
        {
            Persist<T>.Save(instance, false);
        }

        ///<summary>Save an instance to the persistence store</summary>
        ///<param name="includeChildren">Include changes to related child instances</param>
        ///<exception cref="ValidationException">Throws VaidationException when not <see cref="IsValid"/>.</exception>
		public static void Save(T instance, bool includeChildren)
        {
			if (instance == null)
				throw new ArgumentNullException("instance");

			if (DataManager.ObjectSpace.GetObjectState(instance) == ObjectState.Unknown)
                DataManager.ObjectSpace.StartTracking(instance, InitialState.Inserted);

            PersistDepth depth = includeChildren ? PersistDepth.ObjectGraph : PersistDepth.SingleObject;
            DataManager.ObjectSpace.PersistChanges(instance, depth);

			instance.MarkAsClean();
        }

        ///<summary>Save an instance to the persistence store using a transaction</summary>
        ///<param name="transaction">An instance of a Wilson.ORMapper.Transaction to perform operation with.</param>
        ///<exception cref="ValidationException">Throws VaidationException when not <see cref="IsValid"/>.</exception>
		public static void Save(T instance, Wilson.ORMapper.Transaction transaction)
        {
            Save(instance, transaction, false);
        }

        ///<summary>Save an instance to the persistence store using a transaction</summary>
        ///<param name="transaction">An instance of a Wilson.ORMapper.Transaction to perform operation with.</param>
        ///<param name="includeChildren">Include changes to related child instances</param>
        ///<exception cref="ValidationException">Throws VaidationException when not <see cref="IsValid"/>.</exception>
		public static void Save(T instance, Wilson.ORMapper.Transaction transaction, bool includeChildren)
        {
			if (instance == null)
				throw new ArgumentNullException("instance");

			if (transaction == null)
                throw new ArgumentNullException("transaction");

            if (DataManager.ObjectSpace.GetObjectState(instance) == ObjectState.Unknown)
                DataManager.ObjectSpace.StartTracking(instance, InitialState.Inserted);

            PersistDepth depth = includeChildren ? PersistDepth.ObjectGraph : PersistDepth.SingleObject;
            transaction.PersistChanges(instance, depth);

			instance.MarkAsClean();
        }
        #endregion		

        #region Delete
		///<summary>Deletes the specified instance from the persistence store/</summary>
		///<param name="instance">The instance to delete.</param>
		///<remarks>This method can be used for the <see cref="ObjectDataSource.DeleteMethod"/>.</remarks>
		///<returns>The number of affected rows.</returns>
		///<seealso cref="ObjectDataSource"/>
		[DataObjectMethod(DataObjectMethodType.Delete, true)]
		public static int Delete(T instance)
        {
			if (instance == null)
				throw new ArgumentNullException("instance");

			if (DataManager.ObjectSpace.GetObjectState(instance) == ObjectState.Unknown)
                return 0;

            DataManager.ObjectSpace.MarkForDeletion(instance);
            DataManager.ObjectSpace.PersistChanges(instance);

			instance.MarkAsDeleted();

			return 1;
        }
        
        ///<summary>Delete an instance from the persistence store using a transaction</summary>
        ///<param name="transaction">An instance of a Wilson.ORMapper.Transaction to perform operation with.</param>
        public static void Delete(T instance, Wilson.ORMapper.Transaction transaction)
        {
			if (instance == null)
				throw new ArgumentNullException("instance");

			if (transaction == null)
                throw new ArgumentNullException("transaction");

            if (DataManager.ObjectSpace.GetObjectState(instance) == ObjectState.Unknown)
                return;

            DataManager.ObjectSpace.MarkForDeletion(instance);
            transaction.PersistChanges(instance);

			instance.MarkAsDeleted();
        }

        ///<summary>Delete instances from the persistence store based on the where clause</summary>
        ///<param name="whereClause">The SQL where clause of rows to delete</param>
        public static int Delete(string whereClause)
        {
            return DataManager.ObjectSpace.ExecuteDelete(typeof(T), whereClause);
        }

        ///<summary>Delete instances from the persistence store based on the where clause</summary>
        ///<param name="transaction">An instance of a Wilson.ORMapper.Transaction to perform operation with.</param>
        ///<param name="whereClause">The SQL where clause of rows to delete</param>
        public static int Delete(Wilson.ORMapper.Transaction transaction, string whereClause)
        {
            if (transaction == null)
                throw new ArgumentNullException("transaction");

            return transaction.ExecuteDelete(typeof(T), whereClause);
        }

		[DataObjectMethod(DataObjectMethodType.Delete)]
		public static int DeleteByKey(IIdentity identity)
		{
			string where = GetPrimaryKeyWhereClause(identity);
			return Delete(where);
		}

		[DataObjectMethod(DataObjectMethodType.Delete)]
		public static int DeleteByKey(Wilson.ORMapper.Transaction transaction, IIdentity identity)
		{
			string where = GetPrimaryKeyWhereClause(identity);
			return Delete(transaction, where);
		}

        #endregion

        #region Update
        /// <summary>Updates the specified instance.</summary>
        /// <param name="instance">The instance to update.</param>
        ///<remarks>This method can be used for the <see cref="ObjectDataSource.UpdateMethod"/>.</remarks>
        ///<returns>The number of affected rows.</returns>
		///<seealso cref="ObjectDataSource"/>
        [DataObjectMethod(DataObjectMethodType.Update, true)]
        public static int Update(T instance)
        {
            if (instance == null)
                throw new ArgumentNullException("instance");
            
            if (DataManager.ObjectSpace.GetObjectState(instance) == ObjectState.Unknown)
                DataManager.ObjectSpace.StartTracking(instance, InitialState.Updated);

			Persist<T>.Save(instance);
			return 1;
        }

        ///<summary>Updates instances from the persistence store based on the where clause and uses the Update clause to set the values</summary>
        ///<param name="whereClause">The SQL where clause of rows to update</param>
        ///<param name="updateClause">The SQL update clause for values to set</param>
        public static int Update(string whereClause, string updateClause)
        {
            return DataManager.ObjectSpace.ExecuteUpdate(typeof(T), whereClause, updateClause);
        }

        ///<summary>Updates instances from the persistence store based on the where clause and uses the Update clause to set the values</summary>
        ///<param name="transaction">An instance of a Wilson.ORMapper.Transaction to perform operation with.</param>
        ///<param name="whereClause">The SQL where clause of rows to update</param>
        ///<param name="updateClause">The SQL update clause for values to set</param>
        public static int Update(Wilson.ORMapper.Transaction transaction, string whereClause, string updateClause)
        {
            if (transaction == null)
                throw new ArgumentNullException("transaction");

            return transaction.ExecuteUpdate(typeof(T), whereClause, updateClause);
        } 
        #endregion

        #region Insert
        /// <summary>Inserts the specified instance.</summary>
        /// <param name="instance">The instance to insert.</param>
        ///<remarks>This method can be used for the <see cref="ObjectDataSource.InsertMethod"/>.</remarks>
        ///<returns>The number of affected rows.</returns>
		///<seealso cref="ObjectDataSource"/>
        [DataObjectMethod(DataObjectMethodType.Insert, true)]
        public static int Insert(T instance)
        {
            if (instance == null)
                throw new ArgumentNullException("instance");

			Persist<T>.Save(instance);
			return 1;
        } 
        #endregion

		#region New
		public static T New()
		{
			T obj = new T();
			DataManager.ObjectSpace.StartTracking(obj, InitialState.Inserted);

			obj.MarkAsDirty();

			return obj;
		}
		public static void Track(T obj)
		{
			DataManager.ObjectSpace.StartTracking(obj, InitialState.Inserted);

			obj.MarkAsDirty();
		}
		#endregion
	}
}
